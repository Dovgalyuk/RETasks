# auth_overflow

Входные данные: `1234567890123456AAAAAAAAAAAAA`

Интуиция подсказывала, что должно подойти и `1234567890123456A`, но после дизасемблирования с помощью Ghidra оказалось, что в массие выделяется место под 28 элементов. Это работает, поскольку в стэке значение `auth_flag` находится над `password_buffer`, соответвенно при переполнении `password_buffer` с помощью `strcpy`(в которой нет защиты от переполнения) перезаписывается значение в `auth_flag`, а любое значение, отличное от 0 интерпетируется как true

# auth_overlow2

Входные данные: в файле payload(из-за непечатных символов)

Для "взлома" прораммы необхдимо подменить адрес возврата из `check_authentication`. С помощью Ghidra выяняем, что нам подойдут `00400652`-`00400657`(если мы хотим сделать вид, что в if условие выполнилось) или `004005a7`(если хотим просто сразу после выхода вызывать `granted`). Я выбрал адрес `00400652`. Теперь нужно понять, куда его подставить. Для этого с помощью `gdb`:
1) Запускаю `auth_overflow2`(`gdb auth_overlow2`)
2) Добавляю брей-поинт на `check_auth`(`break check_authentication`)
3) Запускаю выполнение(`run`)
4) Зыполняю команды, чтобы дойти до первого `if` в функции введя пароль "123"(`step`, `fin`, `123`)
4) Выясняю, где сейчас находится вершина стека(`info registers` и там смотрю значение `sp`)
5) Смотрю, что находится в стеке, вижу там байты введёного пароля(`0x31`, `0x32`, `0x33`, `0x00`), какие-то непонятные байты и адрес возврата в main(`0x00`, `0x40`, `0x06`, `0x4e`)(`x/64bx 0x7fffffffd140`)
6) С помощью программы на python готовлю payload, который оставит все байты стека идентичными, но подменит адрес возврата на `00400652`(код в `hack_auth_overflow2.py`)
7) Запускаю программу, передав в неё подготовленный payload(`./auth_overlow2 < payload`)
