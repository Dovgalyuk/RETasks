unsigned int fd2(unsigned int a, unsigned int b)
{
    return a / b;
}
/*
 O0:
 0000000000001129 <fd2>:
    1129:  f3 0f 1e fa            endbr64
    112d:  55                     push   %rbp
    112e:  48 89 e5               mov    %rsp,%rbp
    1131:  89 7d fc               mov    %edi,-0x4(%rbp)
    1134:  89 75 f8               mov    %esi,-0x8(%rbp)
    1137:  8b 45 fc               mov    -0x4(%rbp),%eax
    113a:  ba 00 00 00 00         mov    $0x0,%edx
    113f:  f7 75 f8               divl   -0x8(%rbp)
    1142:  5d                     pop    %rbp
    1143:  c3                     retq

  O2
  0000000000001140 <fd2>:
    1140:  f3 0f 1e fa            endbr64
    1144:  89 f8                  mov    %edi,%eax
    1146:  31 d2                  xor    %edx,%edx
    1148:  f7 f6                  div    %esi
    114a:  c3                     retq
    114b:  0f 1f 44 00 00         nopl   0x0(%rax,%rax,1)

    Со вторым уровнем оптимизации больше не происходит выделение памяти на стеке, взаимодействие параметоров происходит
    на уровне регистров аргументов функции.
 */

unsigned int fd3(unsigned int a)
{
    return a % 10;
}

/*
 O0
 0000000000001129 <fd3>:
    1129:  f3 0f 1e fa            endbr64
    112d:  55                     push   %rbp
    112e:  48 89 e5               mov    %rsp,%rbp
    1131:  89 7d fc               mov    %edi,-0x4(%rbp)
    1134:  8b 4d fc               mov    -0x4(%rbp),%ecx
    1137:  89 ca                  mov    %ecx,%edx
    1139:  b8 cd cc cc cc         mov    $0xcccccccd,%eax
    113e:  48 0f af c2            imul   %rdx,%rax
    1142:  48 c1 e8 20            shr    $0x20,%rax
    1146:  89 c2                  mov    %eax,%edx
    1148:  c1 ea 03               shr    $0x3,%edx
    114b:  89 d0                  mov    %edx,%eax
    114d:  c1 e0 02               shl    $0x2,%eax
    1150:  01 d0                  add    %edx,%eax
    1152:  01 c0                  add    %eax,%eax
    1154:  29 c1                  sub    %eax,%ecx
    1156:  89 ca                  mov    %ecx,%edx
    1158:  89 d0                  mov    %edx,%eax
    115a:  5d                     pop    %rbp
    115b:  c3                     retq
    O2
    0000000000001140 <fd3>:
    1140:  f3 0f 1e fa            endbr64
    1144:  89 f8                  mov    %edi,%eax
    1146:  ba cd cc cc cc         mov    $0xcccccccd,%edx
    114b:  48 0f af c2            imul   %rdx,%rax
    114f:  48 c1 e8 23            shr    $0x23,%rax
    1153:  8d 04 80               lea    (%rax,%rax,4),%eax
    1156:  01 c0                  add    %eax,%eax
    1158:  29 c7                  sub    %eax,%edi
    115a:  89 f8                  mov    %edi,%eax
    115c:  c3                     retq
    115d:  0f 1f 00               nopl   (%rax)

    Аналогично, без оптимизаций агрумент попадает на стек для последующих взаимодействий.
    Во втором случае вссё происходит через работу с регистрами напрямую.

    Такк же подготовка делителя присходит не серей команд
        1146:  89 c2                  mov    %eax,%edx
        1148:  c1 ea 03               shr    $0x3,%edx
        114b:  89 d0                  mov    %edx,%eax
        114d:  c1 e0 02               shl    $0x2,%eax
    , а упрощается до
        1153:  8d 04 80               lea    (%rax,%rax,4),%eax
 */

unsigned int fd4(unsigned int a)
{
    return a % 16;
}
/*
 O0
0000000000001129 <fd4>:
    1129:  f3 0f 1e fa            endbr64
    112d:  55                     push   %rbp
    112e:  48 89 e5               mov    %rsp,%rbp
    1131:  89 7d fc               mov    %edi,-0x4(%rbp)
    1134:  8b 45 fc               mov    -0x4(%rbp),%eax
    1137:  83 e0 0f               and    $0xf,%eax
    113a:  5d                     pop    %rbp
    113b:  c3                     retq

    O2
0000000000001140 <fd4>:
    1140:  f3 0f 1e fa            endbr64
    1144:  89 f8                  mov    %edi,%eax
    1146:  83 e0 0f               and    $0xf,%eax
    1149:  c3                     retq
    114a:  66 0f 1f 44 00 00      nopw   0x0(%rax,%rax,1)

    Аналогично, без оптимизаций агрумент попадает на стек для последующих взаимодействий: mov    %edi,-0x4(%rbp).
    Во втором случае вссё происходит через работу с регистрами напрямую через регистр edi.
 */

int f1(int a)
{
    switch (a)
    {
    case 1:
        return 5;
    case 6:
        return 7;
    case 10:
        return 3;
    }
    return 0;
}
/*
 O0
 0000000000001129 <f1>:
    1129:  f3 0f 1e fa            endbr64
    112d:  55                     push   %rbp
    112e:  48 89 e5               mov    %rsp,%rbp
    1131:  89 7d fc               mov    %edi,-0x4(%rbp)
    Сохранение значения агрумента на стеке со смещнием -4
    1134:  83 7d fc 0a            cmpl   $0xa,-0x4(%rbp)
    1138:  74 22                  je     115c <f1+0x33>
    113a:  83 7d fc 0a            cmpl   $0xa,-0x4(%rbp)
    113e:  7f 23                  jg     1163 <f1+0x3a>
    1140:  83 7d fc 01            cmpl   $0x1,-0x4(%rbp)
    1144:  74 08                  je     114e <f1+0x25>
    1146:  83 7d fc 06            cmpl   $0x6,-0x4(%rbp)
    114a:  74 09                  je     1155 <f1+0x2c>
    Последовательное сравнение
    Общая логика последовательных сравнений заключается в том,
    что в случае успешного  равнения на равенство, происходит переход на команду,
    записывающую нужное значение в регистр возврата.
    114c:  eb 15                  jmp    1163 <f1+0x3a>
    114e:  b8 05 00 00 00         mov    $0x5,%eax
    1153:  eb 13                  jmp    1168 <f1+0x3f>
    1155:  b8 07 00 00 00         mov    $0x7,%eax
    115a:  eb 0c                  jmp    1168 <f1+0x3f>
    115c:  b8 03 00 00 00         mov    $0x3,%eax
    1161:  eb 05                  jmp    1168 <f1+0x3f>
    1163:  b8 00 00 00 00         mov    $0x0,%eax
    И после происходит переход в конец фенкции.
    1168:  5d                     pop    %rbp
    1169:  c3                     retq

    O2
    0000000000001140 <f1>:
    1140:  f3 0f 1e fa            endbr64
    1144:  83 ef 01               sub    $0x1,%edi
    1147:  31 c0                  xor    %eax,%eax
    1149:  83 ff 09               cmp    $0x9,%edi
    114c:  77 0a                  ja     1158 <f1+0x18>
    114e:  48 8d 05 cb 0e 00 00   lea    0xecb(%rip),%rax        # 2020 <CSWTCH.1>
    1155:  8b 04 b8               mov    (%rax,%rdi,4),%eax
    1158:  c3                     retq
    1159:  0f 1f 80 00 00 00 00   nopl   0x0(%rax)

    0000000000002020 <CSWTCH.1>:
    2020:  05 00 00 00 00         add    $0x0,%eax
  ...
    2031:  00 00                  add    %al,(%rax)
    2033:  00 07                  add    %al,(%rdi)
  ...
    2041:  00 00                  add    %al,(%rax)
    2043:  00 03                  add    %al,(%rbx)
    2045:  00 00                  add    %al,(%rax)

    В случае оптимизации можно наблюдать картину использование аргумента в регистре edi сразу же,
    без выделения места на стеке.
    Далее, без оптимизации сначала происходит сравнение, потом переход на участок, где регистру возврата присваивается
    значение и только полсе преход в конец функции.
    В оптимизированном варианте результат безётся из таблицы переходов CSWTCH.1
 */

int f2(int a)
{
    switch (a)
    {
    case 1:
        return 5;
    case 6:
        return 7;
    case 10:
        return 3;
    case 1000:
        return 9;
    case 6000:
        return 8;
    case 10000:
        return 4;
    }
    return 0;
}

/*
 O0
 0000000000001129 <f2>:
    1129:  f3 0f 1e fa            endbr64
    112d:  55                     push   %rbp
    112e:  48 89 e5               mov    %rsp,%rbp
    1131:  89 7d fc               mov    %edi,-0x4(%rbp)
    Сохранение значения агрумента на стеке со смещнием -4
    1134:  81 7d fc 10 27 00 00   cmpl   $0x2710,-0x4(%rbp)
    113b:  74 6a                  je     11a7 <f2+0x7e>
    113d:  81 7d fc 10 27 00 00   cmpl   $0x2710,-0x4(%rbp)
    1144:  7f 68                  jg     11ae <f2+0x85>
    1146:  81 7d fc 70 17 00 00   cmpl   $0x1770,-0x4(%rbp)
    114d:  74 51                  je     11a0 <f2+0x77>
    114f:  81 7d fc 70 17 00 00   cmpl   $0x1770,-0x4(%rbp)
    1156:  7f 56                  jg     11ae <f2+0x85>
    1158:  81 7d fc e8 03 00 00   cmpl   $0x3e8,-0x4(%rbp)
    115f:  74 38                  je     1199 <f2+0x70>
    1161:  81 7d fc e8 03 00 00   cmpl   $0x3e8,-0x4(%rbp)
    1168:  7f 44                  jg     11ae <f2+0x85>
    116a:  83 7d fc 0a            cmpl   $0xa,-0x4(%rbp)
    116e:  74 22                  je     1192 <f2+0x69>
    1170:  83 7d fc 0a            cmpl   $0xa,-0x4(%rbp)
    1174:  7f 38                  jg     11ae <f2+0x85>
    1176:  83 7d fc 01            cmpl   $0x1,-0x4(%rbp)
    117a:  74 08                  je     1184 <f2+0x5b>
    117c:  83 7d fc 06            cmpl   $0x6,-0x4(%rbp)
    1180:  74 09                  je     118b <f2+0x62>
    Последовательное сравнение
    Общая логика последовательных сравнений заключается в том,
    что в случае успешного  равнения на равенство, происходит переход на команду,
    записывающую нужное значение в регистр возврата.
    1182:  eb 2a                  jmp    11ae <f2+0x85>
    1184:  b8 05 00 00 00         mov    $0x5,%eax
    1189:  eb 28                  jmp    11b3 <f2+0x8a>
    118b:  b8 07 00 00 00         mov    $0x7,%eax
    1190:  eb 21                  jmp    11b3 <f2+0x8a>
    1192:  b8 03 00 00 00         mov    $0x3,%eax
    1197:  eb 1a                  jmp    11b3 <f2+0x8a>
    1199:  b8 09 00 00 00         mov    $0x9,%eax
    119e:  eb 13                  jmp    11b3 <f2+0x8a>
    11a0:  b8 08 00 00 00         mov    $0x8,%eax
    11a5:  eb 0c                  jmp    11b3 <f2+0x8a>
    11a7:  b8 04 00 00 00         mov    $0x4,%eax
    11ac:  eb 05                  jmp    11b3 <f2+0x8a>
    11ae:  b8 00 00 00 00         mov    $0x0,%eax
    И после происходит переход в конец фенкции.
    11b3:  5d                     pop    %rbp
    11b4:  c3                     retq

    O2
    0000000000001140 <f2>:
    1140:  f3 0f 1e fa            endbr64
    1144:  81 ff e8 03 00 00      cmp    $0x3e8,%edi
    114a:  74 4c                  je     1198 <f2+0x58>
    114c:  7f 2a                  jg     1178 <f2+0x38>
    114e:  b8 07 00 00 00         mov    $0x7,%eax
    1153:  83 ff 06               cmp    $0x6,%edi
    1156:  74 0a                  je     1162 <f2+0x22>
    1158:  b8 03 00 00 00         mov    $0x3,%eax
    115d:  83 ff 0a               cmp    $0xa,%edi
    1160:  75 06                  jne    1168 <f2+0x28>
    1162:  c3                     retq
    1163:  0f 1f 44 00 00         nopl   0x0(%rax,%rax,1)
    1168:  31 c0                  xor    %eax,%eax
    116a:  83 ff 01               cmp    $0x1,%edi
    116d:  0f 94 c0               sete   %al
    1170:  8d 04 80               lea    (%rax,%rax,4),%eax
    1173:  c3                     retq
    1174:  0f 1f 40 00            nopl   0x0(%rax)
    1178:  b8 08 00 00 00         mov    $0x8,%eax
    117d:  81 ff 70 17 00 00      cmp    $0x1770,%edi
    1183:  74 dd                  je     1162 <f2+0x22>
    1185:  31 c0                  xor    %eax,%eax
    1187:  81 ff 10 27 00 00      cmp    $0x2710,%edi
    118d:  0f 94 c0               sete   %al
    1190:  c1 e0 02               shl    $0x2,%eax
    1193:  c3                     retq
    1194:  0f 1f 40 00            nopl   0x0(%rax)
    1198:  b8 09 00 00 00         mov    $0x9,%eax
    119d:  c3                     retq
    119e:  66 90                  xchg   %ax,%ax


    В случае оптимизации можно наблюдать картину использование аргумента в регистре edi сразу же,
    без выделения места на стеке.
    Далее, без оптимизации сначала происходит сравнение, потом переход на участок, где регистру возврата присваивается
    значение и только полсе преход в конец функции.
    С оптимизаецией запись в регистр возврата происходит сразу после успешного сравнения,
    после чего происходит переход в конец функции.
 */

int if1(int a)
{
    int b = a == 0 ? 1 : 2;
    return b;
}

/*
 O0
 0000000000001129 <if1>:
    1129:  f3 0f 1e fa            endbr64
    112d:  55                     push   %rbp
    112e:  48 89 e5               mov    %rsp,%rbp
    1131:  89 7d ec               mov    %edi,-0x14(%rbp)
    1134:  83 7d ec 00            cmpl   $0x0,-0x14(%rbp)
    1138:  75 07                  jne    1141 <if1+0x18>
    113a:  b8 01 00 00 00         mov    $0x1,%eax
    113f:  eb 05                  jmp    1146 <if1+0x1d>
    1141:  b8 02 00 00 00         mov    $0x2,%eax
    1146:  89 45 fc               mov    %eax,-0x4(%rbp)
    1149:  8b 45 fc               mov    -0x4(%rbp),%eax
    114c:  5d                     pop    %rbp
    114d:  c3                     retq

    O2
    0000000000001140 <if1>:
    1140:  f3 0f 1e fa            endbr64
    1144:  31 c0                  xor    %eax,%eax
    1146:  85 ff                  test   %edi,%edi
    1148:  0f 95 c0               setne  %al
    114b:  83 c0 01               add    $0x1,%eax
    114e:  c3                     retq
    114f:  90                     nop

    Аналогчно, без оптимизации аргумент функции записывается в стке, в то время, как с неё он лежит в edi.

    В неоптимизированном варианте происходит последовательное выполнение всех операций, в то время как в оптимизированом
    всё сводится к обнулению значения регистра вывода -> если аргумент равен 0 (о чём говорит флаг ZF)
    записываем 1 в регистр возврата -> в итоге добавляем к регистру возврата 1.

    Так же в оптимизированном варианте нет выделения памяти под переменную b, а результат пишется сразу в eax
 */
int if2(int a)
{
    int b = a == 50 ? 12 : 26;
    return b;
}
/*
 O0
 0000000000001129 <if2>:
    1129:  f3 0f 1e fa            endbr64
    112d:  55                     push   %rbp
    112e:  48 89 e5               mov    %rsp,%rbp
    1131:  89 7d ec               mov    %edi,-0x14(%rbp)
    1134:  83 7d ec 32            cmpl   $0x32,-0x14(%rbp)
    1138:  75 07                  jne    1141 <if2+0x18>
    113a:  b8 0c 00 00 00         mov    $0xc,%eax
    113f:  eb 05                  jmp    1146 <if2+0x1d>
    1141:  b8 1a 00 00 00         mov    $0x1a,%eax
    1146:  89 45 fc               mov    %eax,-0x4(%rbp)
    1149:  8b 45 fc               mov    -0x4(%rbp),%eax
    114c:  5d                     pop    %rbp
    114d:  c3                     retq

    O2
    0000000000001140 <if2>:
    1140:  f3 0f 1e fa            endbr64
    1144:  83 ff 32               cmp    $0x32,%edi
    1147:  ba 1a 00 00 00         mov    $0x1a,%edx
    114c:  b8 0c 00 00 00         mov    $0xc,%eax
    1151:  0f 45 c2               cmovne %edx,%eax
    1154:  c3                     retq
    1155:  66 2e 0f 1f 84 00 00   nopw   %cs:0x0(%rax,%rax,1)
    115c:  00 00 00
    115f:  90                     nop

    Аналогично, с оптимизацие не выделяется памятьна стеке, а используется значение в регистре.
    Без оптимизации происходит сравнение, после чего происходит переход к участку, где регистру возврата присваивается
    нужное значение, после чего это же значение присваивается переменной b (mov    %eax,-0x4(%rbp)), чтобы...
    Потом обратно присвоить его регистру возврата.
    С оптимизацией в регистр возврата сразу записывается 12, а в случае успешного сравнения(cmovne %edx,%eax),
    туда записывается 26. Переменая b вообще не используется в данном случае.

 */
int if4(int a, int b, int c)
{
    if (a || c == b)
        return b;
    else
        return a;
}
/*
 O0
 0000000000001129 <if4>:
    1129:  f3 0f 1e fa            endbr64
    112d:  55                     push   %rbp
    112e:  48 89 e5               mov    %rsp,%rbp
    1131:  89 7d fc               mov    %edi,-0x4(%rbp)
    1134:  89 75 f8               mov    %esi,-0x8(%rbp)
    1137:  89 55 f4               mov    %edx,-0xc(%rbp)
    113a:  83 7d fc 00            cmpl   $0x0,-0x4(%rbp)
    113e:  75 08                  jne    1148 <if4+0x1f>
    1140:  8b 45 f4               mov    -0xc(%rbp),%eax
    1143:  3b 45 f8               cmp    -0x8(%rbp),%eax
    1146:  75 05                  jne    114d <if4+0x24>
    1148:  8b 45 f8               mov    -0x8(%rbp),%eax
    114b:  eb 03                  jmp    1150 <if4+0x27>
    114d:  8b 45 fc               mov    -0x4(%rbp),%eax
    1150:  5d                     pop    %rbp
    1151:  c3                     retq

    O2
    0000000000001140 <if4>:
    1140:  f3 0f 1e fa            endbr64
    1144:  85 ff                  test   %edi,%edi
    1146:  75 08                  jne    1150 <if4+0x10>
    1148:  31 c0                  xor    %eax,%eax
    114a:  39 f2                  cmp    %esi,%edx
    114c:  74 02                  je     1150 <if4+0x10>
    114e:  c3                     retq
    114f:  90                     nop
    1150:  89 f0                  mov    %esi,%eax
    1152:  c3                     retq
    1153:  66 2e 0f 1f 84 00 00   nopw   %cs:0x0(%rax,%rax,1)
    115a:  00 00 00
    115d:  0f 1f 00               nopl   (%rax)

    Классически, в оптимизированном варианте не происходит выделение памяти на стеке под аргументы функции.
    Ветвление так же, как и в вариантах выше, реализовано с помощью операторов test, cmp без проежуточных результатов.
    В регистр возврата кладётся сразу некоторое значение и, в случае успешных сравнений, оно перезаписывается на другое
 */
int *s[100];
int t[100];
void f2()
{
    for (int i = 0 ; i != 100 ; ++i)
        s[i] = &t[i];
}
/*
 O0
 0000000000001129 <f2>:
    1129:  f3 0f 1e fa            endbr64
    112d:  55                     push   %rbp
    112e:  48 89 e5               mov    %rsp,%rbp
    1131:  c7 45 fc 00 00 00 00   movl   $0x0,-0x4(%rbp)
    1138:  eb 34                  jmp    116e <f2+0x45>
    113a:  8b 45 fc               mov    -0x4(%rbp),%eax
    113d:  48 98                  cltq
    113f:  48 8d 14 85 00 00 00   lea    0x0(,%rax,4),%rdx
    1146:  00
    1147:  48 8d 05 f2 2e 00 00   lea    0x2ef2(%rip),%rax        # 4040 <t>
    114e:  48 8d 0c 02            lea    (%rdx,%rax,1),%rcx
    1152:  8b 45 fc               mov    -0x4(%rbp),%eax
    1155:  48 98                  cltq
    1157:  48 8d 14 c5 00 00 00   lea    0x0(,%rax,8),%rdx
    115e:  00
    115f:  48 8d 05 7a 30 00 00   lea    0x307a(%rip),%rax        # 41e0 <s>
    1166:  48 89 0c 02            mov    %rcx,(%rdx,%rax,1)
    116a:  83 45 fc 01            addl   $0x1,-0x4(%rbp)
    116e:  83 7d fc 64            cmpl   $0x64,-0x4(%rbp)
    1172:  75 c6                  jne    113a <f2+0x11>
    1174:  90                     nop
    1175:  90                     nop
    1176:  5d                     pop    %rbp
    1177:  c3                     retq

    O2
    0000000000001140 <f2>:
    1140:  f3 0f 1e fa            endbr64
    1144:  48 8d 05 f5 2e 00 00   lea    0x2ef5(%rip),%rax        # 4040 <t>
    114b:  48 8d 15 8e 30 00 00   lea    0x308e(%rip),%rdx        # 41e0 <s>
    1152:  48 8d 88 90 01 00 00   lea    0x190(%rax),%rcx
    1159:  0f 1f 80 00 00 00 00   nopl   0x0(%rax)
    1160:  48 89 02               mov    %rax,(%rdx)
    1163:  48 83 c0 04            add    $0x4,%rax
    1167:  48 83 c2 08            add    $0x8,%rdx
    116b:  48 39 c8               cmp    %rcx,%rax
    116e:  75 f0                  jne    1160 <f2+0x20>
    1170:  c3                     retq
    1171:  66 2e 0f 1f 84 00 00   nopw   %cs:0x0(%rax,%rax,1)
    1178:  00 00 00
    117b:  0f 1f 44 00 00         nopl   0x0(%rax,%rax,1)

    Классически без оптимизации мы обнаруживаем выделение памяти на стеке. В данном случае, од переменную i
    (movl   $0x0,-0x4(%rbp))
    Далее мы наблюдаем вполне ожидаемые конструкции:
     116a:  83 45 fc 01            addl   $0x1,-0x4(%rbp) - увеличиваем i на 1
     116e:  83 7d fc 64            cmpl   $0x64,-0x4(%rbp) - сравниваем его с 100
     1172:  75 c6                  jne    113a <f2+0x11> - конец цикла, если условие не удовлетворено

     В оптимизированном варианте сравнение ужимается до:
     116b:  48 39 c8               cmp    %rcx,%rax - проверка на достижние rdx rcx, где rcx -
     смещение от начла массива rdx в 400 байт = 100 элементов по 4 байта (размер int)
     116e:  75 f0                  jne    1160 <f2+0x20> - аналогично первому.

     И если в первом интерация по массиву была реализована с помощью итератора i, то в оптимизированном варианте
     итерация происходит через смещение начала массива + размер элемента.
    1163:  48 83 c0 04            add    $0x4,%rax
    1167:  48 83 c2 08            add    $0x8,%rdx
 */

void g();

void f1(int a)
{
    while (a)
    {
        --a;
        g();
    }
}
/*
 O0
 0000000000001129 <g>:
    1129:  f3 0f 1e fa            endbr64
    112d:  55                     push   %rbp
    112e:  48 89 e5               mov    %rsp,%rbp
    1131:  90                     nop
    1132:  5d                     pop    %rbp
    1133:  c3                     retq

0000000000001134 <f1>:
    1134:  f3 0f 1e fa            endbr64
    1138:  55                     push   %rbp
    1139:  48 89 e5               mov    %rsp,%rbp
    113c:  48 83 ec 08            sub    $0x8,%rsp
    1140:  89 7d fc               mov    %edi,-0x4(%rbp)
    Выделение памяти под переменную цикла, полученную кк аргумент через edi
    1143:  eb 0e                  jmp    1153 <f1+0x1f>
    Переход в тело цикла, точнее прыжок к условию
    1145:  83 6d fc 01            subl   $0x1,-0x4(%rbp)
    Отнимаем от а единицу
    1149:  b8 00 00 00 00         mov    $0x0,%eax
    Записываем 0 в регистр возврата.
    114e:  e8 d6 ff ff ff         callq  1129 <g>
    Вызов g
    1153:  83 7d fc 00            cmpl   $0x0,-0x4(%rbp)
    1157:  75 ec                  jne    1145 <f1+0x11>
    1159:  90                     nop
    115a:  90                     nop
    115b:  c9                     leaveq
    115c:  c3                     retq

    O2
    0000000000001140 <g>:
    1140:  f3 0f 1e fa            endbr64
    1144:  c3                     retq
    1145:  66 66 2e 0f 1f 84 00   data16 nopw %cs:0x0(%rax,%rax,1)
    114c:  00 00 00 00

0000000000001150 <f1>:
    1150:  f3 0f 1e fa            endbr64
    1154:  c3                     retq
    1155:  66 2e 0f 1f 84 00 00   nopw   %cs:0x0(%rax,%rax,1)
    115c:  00 00 00
    115f:  90                     nop

    Функция g()
    Без оптимизации есть только эпилог и пролог функции, после чего возврат.
    С оптимизацией только возврат.
    Функция f1()
    Без оптимизации всё описано в коментария к коду.
    С оптимизацией, потому что функция е совершает полезных действий, она ужимается сразу до возврата.
 */
void f2(int a)
{
L:
    if (a)
    {
        --a;
        g();
        goto L;
    }
}
/*
 O0
 0000000000001129 <g>:
    1129:  f3 0f 1e fa            endbr64
    112d:  55                     push   %rbp
    112e:  48 89 e5               mov    %rsp,%rbp
    1131:  90                     nop
    1132:  5d                     pop    %rbp
    1133:  c3                     retq

0000000000001134 <f2>:
    1134:  f3 0f 1e fa            endbr64
    1138:  55                     push   %rbp
    1139:  48 89 e5               mov    %rsp,%rbp
    113c:  48 83 ec 08            sub    $0x8,%rsp
    1140:  89 7d fc               mov    %edi,-0x4(%rbp)
    Выделение памяти под a на стеке
    1143:  83 7d fc 00            cmpl   $0x0,-0x4(%rbp)
    Сравнение а и 0
    1147:  74 10                  je     1159 <f2+0x25>
    Если а не равно 0
    1149:  83 6d fc 01            subl   $0x1,-0x4(%rbp)
    а - 1
    114d:  b8 00 00 00 00         mov    $0x0,%eax
    0 записывается в регистр возврата
    1152:  e8 d2 ff ff ff         callq  1129 <g>
    Вызов g
    1157:  eb ea                  jmp    1143 <f2+0xf>
    Прыжок к L
    1159:  90                     nop
    115a:  c9                     leaveq
    115b:  c3                     retq

    O2
    0000000000001140 <g>:
    1140:  f3 0f 1e fa            endbr64
    1144:  c3                     retq
    1145:  66 66 2e 0f 1f 84 00   data16 nopw %cs:0x0(%rax,%rax,1)
    114c:  00 00 00 00

0000000000001150 <f2>:
    1150:  f3 0f 1e fa            endbr64
    1154:  c3                     retq
    1155:  66 2e 0f 1f 84 00 00   nopw   %cs:0x0(%rax,%rax,1)
    115c:  00 00 00
    115f:  90                     nop

    Аналогично примеры выше.
    Из-за отсутствия полезной нагрузки функция ужимается до возврата.
 */
void f4(int a)
{
    do
    {
        --a;
        g();
    }
    while (a);
}
/*
 O0
0000000000001129 <g>:
    1129:  f3 0f 1e fa            endbr64
    112d:  55                     push   %rbp
    112e:  48 89 e5               mov    %rsp,%rbp
    1131:  90                     nop
    1132:  5d                     pop    %rbp
    1133:  c3                     retq

0000000000001134 <f4>:
    1134:  f3 0f 1e fa            endbr64
    1138:  55                     push   %rbp
    1139:  48 89 e5               mov    %rsp,%rbp
    113c:  48 83 ec 08            sub    $0x8,%rsp
    1140:  89 7d fc               mov    %edi,-0x4(%rbp)
    Выделение памяти под a на стеке
    1143:  83 6d fc 01            subl   $0x1,-0x4(%rbp)
    Отнимаем от а единицу
    1147:  b8 00 00 00 00         mov    $0x0,%eax
    Записываем 0 в регистр возврата.
    114c:  e8 d8 ff ff ff         callq  1129 <g>
    Вызов g
    1151:  83 7d fc 00            cmpl   $0x0,-0x4(%rbp)
    1155:  75 ec                  jne    1143 <f4+0xf>
    1157:  90                     nop
    1158:  90                     nop
    1159:  c9                     leaveq
    115a:  c3                     retq
 O2
 0000000000001140 <g>:
    1140:  f3 0f 1e fa            endbr64
    1144:  c3                     retq
    1145:  66 66 2e 0f 1f 84 00   data16 nopw %cs:0x0(%rax,%rax,1)
    114c:  00 00 00 00

0000000000001150 <f4>:
    1150:  f3 0f 1e fa            endbr64
    1154:  c3                     retq
    1155:  66 2e 0f 1f 84 00 00   nopw   %cs:0x0(%rax,%rax,1)
    115c:  00 00 00
    115f:  90                     nop

    Аналогично с f1, только цикл заменён на do {...} while(...)
 */
